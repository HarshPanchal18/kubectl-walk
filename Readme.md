# kubectl-walk

Lightweight CLI tool to flatten and inspect nested fields of Kubernetes objects or YAML files. Handy and useful during documenting important field(s) instead of going deeper inside nested block.

Supports any YAML that exists, not only for Kubernetes resource(s).

## Overview

### Standard YAML

```yaml
apiVersion: v1
kind: Pod
metadata:
    name: nginx-pod
    namespace: default
spec:
    containers:
      - image: nginx
        imagePullPolicy: Always
        name: nginx-pod
```

### Transformation

```yaml
apiVersion: v1
kind: Pod
metadata.name: nginx-pod
metadata.namespace: default
spec.containers[0].image: nginx
spec.containers[0].imagePullPolicy: Always
spec.containers[0].name: nginx-pod
```

## Build and Test on local

```bash
# Build the binary from the repository root
go build -o kubectl-walk main.go

# Put binary into the $PATH
chmod +x kubectl-imageof
mv kubectl-imageof ~/.local/bin

# Make sure ~/.local/bin is in your PATH.
echo $PATH

# Or add it via,
export PATH=$PATH:~/.local/bin

# Verify kubectl detects the plugin
kubectl plugin list
```

## Basic usage

```bash
# Inspect a live Kubernetes object (requires kubeconfig)
./kubectl walk pod nginx -n default

# Flatten only a subtree
./kubectl walk pod nginx -n default -e spec.containers

# Read from a YAML file instead of the cluster
./kubectl walk -f ./example.yaml -e spec.containers

# Write output to a file
./kubectl walk -f ./example.yaml -e spec.containers -o output.txt
```

## CLI flags

- `--all`, `-A` : Include empty object value.
- `--depth`, `-d`: depth of walking path
- `--entry`, `-e`: dotted entrypoint (e.g. `spec.containers[0].image`).
- `--file`, `-f`: read YAML from file instead of the cluster.
- `--help`, `-h`: show help (`[`main.printUsage`](main.go)`).
- `--kubeconfig`, `-c`: path to kubeconfig (default `$HOME/.kube/config`).
- `--namespace`, `-n`: namespace (default `default`).
- `--output`, `-o`: write output to a file.
- `--pure`, `-p`: strip auto-generated fields when walking (controlled by the `autoGenerated` map and used in `main.walk`).

## Implementation pointers

- Resource kind normalization is implemented in `main.resolveKind`.
- Dynamic discovery + RESTMapper used in `main.FetchDynamicObject` to resolve GVK/GVR.
- YAML traversal uses the `gopkg.in/yaml.v3` node tree; helper to get map values is `main.getMapValue`.
- Serialization uses Kubernetes runtime serializers in `main.serializeObject`.
